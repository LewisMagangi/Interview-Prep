# DSA for FAANG Interview Preparation Roadmap

## 1. Programming Fundamentals

- [x] **Programming Language Mastery** (Python, Java, C++, or JavaScript)
  - [x] Syntax and basic constructs
  - [x] Object-oriented programming concepts
  - [ ] Memory management
  - [ ] Standard library functions
- [ ] **Time and Space Complexity Analysis**
  - [ ] Big O notation
  - [ ] Best, average, and worst-case scenarios
  - [ ] Space-time tradeoffs
- [ ] **Problem-Solving Techniques**
  - [ ] Breaking down complex problems
  - [ ] Pattern recognition
  - [ ] Edge case identification

## 2. Basic Data Structures

### Arrays

- [ ] **Array Basics**
  - [ ] Array declaration and initialization
  - [ ] Accessing and modifying elements
  - [ ] Array traversal
- [ ] **Array Operations**
  - [ ] Insertion and deletion
  - [ ] Searching (linear and binary)
  - [ ] Sorting algorithms
- [ ] **Multi-dimensional Arrays**
  - [ ] 2D arrays
  - [ ] Matrix operations
- [ ] **Dynamic Arrays**
  - [ ] Resizable arrays (ArrayList, Vector)
  - [ ] Implementation details

### Linked Lists

- [ ] **Singly Linked Lists**
  - [ ] Node structure
  - [ ] Insertion and deletion
  - [ ] Traversal
- [ ] **Doubly Linked Lists**
  - [ ] Implementation
  - [ ] Bidirectional traversal
- [ ] **Circular Linked Lists**
  - [ ] Implementation
  - [ ] Use cases
- [ ] **Linked List Operations**
  - [ ] Reversal
  - [ ] Cycle detection
  - [ ] Merging sorted lists
  - [ ] Finding middle element

### Stacks

- [ ] **Stack Fundamentals**
  - [ ] LIFO principle
  - [ ] Push and pop operations
  - [ ] Stack implementation (array and linked list)
- [ ] **Stack Applications**
  - [ ] Expression evaluation
  - [ ] Parentheses matching
  - [ ] Function call management
  - [ ] Undo operations
- [ ] **Stack Problems**
  - [ ] Valid parentheses
  - [ ] Next greater element
  - [ ] Largest rectangle in histogram

### Queues

- [ ] **Queue Fundamentals**
  - [ ] FIFO principle
  - [ ] Enqueue and dequeue operations
  - [ ] Queue implementation (array and linked list)
- [ ] **Queue Variations**
  - [ ] Circular queue
  - [ ] Priority queue
  - [ ] Deque (double-ended queue)
- [ ] **Queue Applications**
  - [ ] BFS implementation
  - [ ] Process scheduling
  - [ ] Buffer for data streams

## 3. Non-Linear Data Structures

### Trees

- [ ] **Binary Trees**
  - [ ] Tree terminology
  - [ ] Binary tree representation
  - [ ] Tree traversals (inorder, preorder, postorder)
  - [ ] Level-order traversal
- [ ] **Binary Search Trees (BST)**
  - [ ] BST properties
  - [ ] Insertion and deletion
  - [ ] Search operations
  - [ ] BST validation
- [ ] **Balanced Trees**
  - [ ] AVL trees
  - [ ] Red-Black trees
  - [ ] Tree rotations
- [ ] **Tree Algorithms**
  - [ ] Lowest common ancestor
  - [ ] Tree diameter
  - [ ] Path sum problems
  - [ ] Tree serialization/deserialization
- [ ] **Special Trees**
  - [ ] Trie (Prefix Tree)
  - [ ] Segment trees
  - [ ] Fenwick trees (Binary Indexed Tree)

### Heaps

- [ ] **Heap Fundamentals**
  - [ ] Min-heap and max-heap
  - [ ] Heap properties
  - [ ] Array representation
- [ ] **Heap Operations**
  - [ ] Insertion and extraction
  - [ ] Heapify process
  - [ ] Heap sort
- [ ] **Priority Queue**
  - [ ] Implementation using heaps
  - [ ] Applications
- [ ] **Advanced Heap Concepts**
  - [ ] K-way merge
  - [ ] Top K elements
  - [ ] Median finding

### Graphs

- [ ] **Graph Basics**
  - [ ] Graph terminology
  - [ ] Graph representations (adjacency matrix, adjacency list)
  - [ ] Directed vs undirected graphs
  - [ ] Weighted vs unweighted graphs
- [ ] **Graph Traversal**
  - [ ] Depth-First Search (DFS)
  - [ ] Breadth-First Search (BFS)
  - [ ] Topological sorting
- [ ] **Shortest Path Algorithms**
  - [ ] Dijkstra's algorithm
  - [ ] Bellman-Ford algorithm
  - [ ] Floyd-Warshall algorithm
- [ ] **Minimum Spanning Tree**
  - [ ] Kruskal's algorithm
  - [ ] Prim's algorithm
- [ ] **Advanced Graph Algorithms**
  - [ ] Union-Find (Disjoint Set)
  - [ ] Strongly connected components
  - [ ] Network flow algorithms

## 4. Core Algorithms

### Sorting Algorithms

- [ ] **Basic Sorting**
  - [ ] Bubble sort
  - [ ] Selection sort
  - [ ] Insertion sort
- [ ] **Efficient Sorting**
  - [ ] Merge sort
  - [ ] Quick sort
  - [ ] Heap sort
- [ ] **Specialized Sorting**
  - [ ] Counting sort
  - [ ] Radix sort
  - [ ] Bucket sort
- [ ] **Sorting Applications**
  - [ ] External sorting
  - [ ] Stability in sorting
  - [ ] Custom comparators

### Searching Algorithms

- [ ] **Linear Search**
  - [ ] Basic implementation
  - [ ] Variations and optimizations
- [ ] **Binary Search**
  - [ ] Basic binary search
  - [ ] Binary search on answer
  - [ ] Search in rotated arrays
- [ ] **Advanced Searching**
  - [ ] Interpolation search
  - [ ] Exponential search
  - [ ] Ternary search

## 5. Advanced Algorithms and Techniques

### Dynamic Programming

- [ ] **DP Fundamentals**
  - [ ] Overlapping subproblems
  - [ ] Optimal substructure
  - [ ] Memoization vs tabulation
- [ ] **Classic DP Problems**
  - [ ] Fibonacci sequence
  - [ ] Longest common subsequence
  - [ ] Knapsack problems
  - [ ] Coin change problems
- [ ] **Advanced DP Patterns**
  - [ ] Longest increasing subsequence
  - [ ] Edit distance
  - [ ] Matrix chain multiplication
  - [ ] DP on trees
  - [ ] DP with bitmasks

### Greedy Algorithms

- [ ] **Greedy Strategy**
  - [ ] Greedy choice property
  - [ ] Optimal substructure
  - [ ] When to use greedy approach
- [ ] **Classic Greedy Problems**
  - [ ] Activity selection
  - [ ] Fractional knapsack
  - [ ] Huffman coding
  - [ ] Job scheduling

### Divide and Conquer

- [ ] **D&C Principles**
  - [ ] Problem decomposition
  - [ ] Recursive solutions
  - [ ] Combining results
- [ ] **Classic Problems**
  - [ ] Merge sort
  - [ ] Quick sort
  - [ ] Binary search
  - [ ] Maximum subarray sum

### Backtracking

- [ ] **Backtracking Concepts**
  - [ ] State space trees
  - [ ] Pruning techniques
  - [ ] Solution space exploration
- [ ] **Classic Problems**
  - [ ] N-Queens problem
  - [ ] Sudoku solver
  - [ ] Generate permutations
  - [ ] Word search

## 6. Advanced Data Structures

### Hash Tables

- [ ] **Hashing Fundamentals**
  - [ ] Hash functions
  - [ ] Collision resolution
  - [ ] Load factor
- [ ] **Hash Table Implementations**
  - [ ] Chaining
  - [ ] Open addressing
  - [ ] Robin Hood hashing
- [ ] **Applications**
  - [ ] HashSet and HashMap
  - [ ] Caching mechanisms
  - [ ] Bloom filters

### Advanced Trees

- [ ] **B-Trees and B+ Trees**
  - [ ] Structure and properties
  - [ ] Operations and applications
- [ ] **Splay Trees**
  - [ ] Self-adjusting property
  - [ ] Splaying operation
- [ ] **Suffix Trees and Arrays**
  - [ ] Construction algorithms
  - [ ] String matching applications

## 7. Problem-Solving Patterns

### Two Pointers

- [ ] **Basic Two Pointers**
  - [ ] Same direction
  - [ ] Opposite direction
- [ ] **Applications**
  - [ ] Pair sum problems
  - [ ] Palindrome checking
  - [ ] Container with most water

### Sliding Window

- [ ] **Fixed Size Window**
  - [ ] Maximum sum subarray
  - [ ] String anagrams
- [ ] **Variable Size Window**
  - [ ] Longest substring problems
  - [ ] Minimum window substring

### Fast and Slow Pointers

- [ ] **Cycle Detection**
  - [ ] Floyd's algorithm
  - [ ] Finding cycle start
- [ ] **Applications**
  - [ ] Linked list cycle
  - [ ] Happy number
  - [ ] Find duplicate number

### Merge Intervals

- [ ] **Interval Problems**
  - [ ] Merge overlapping intervals
  - [ ] Insert interval
  - [ ] Non-overlapping intervals

## 8. System Design Basics (for Senior Roles)

### Scalability Concepts

- [ ] **Load Balancing**
  - [ ] Types of load balancers
  - [ ] Load balancing algorithms
- [ ] **Caching**
  - [ ] Cache levels
  - [ ] Cache eviction policies
  - [ ] Distributed caching
- [ ] **Database Concepts**
  - [ ] SQL vs NoSQL
  - [ ] Database sharding
  - [ ] Replication and consistency

### Distributed Systems

- [ ] **CAP Theorem**
  - [ ] Consistency, Availability, Partition tolerance
  - [ ] Trade-offs in distributed systems
- [ ] **Consensus Algorithms**
  - [ ] Raft algorithm
  - [ ] Byzantine fault tolerance

## 9. Practice and Interview Preparation

### Coding Practice Platforms

- [ ] **LeetCode**
  - [ ] Easy problems (150+)
  - [ ] Medium problems (300+)
  - [ ] Hard problems (100+)
- [ ] **HackerRank**
  - [ ] Data structures track
  - [ ] Algorithms track
- [ ] **GeeksforGeeks**
  - [ ] Company-specific problems
  - [ ] Topic-wise practice
- [ ] **Codeforces**
  - [ ] Competitive programming practice

### Mock Interviews

- [ ] **Interview Platforms**
  - [ ] Pramp
  - [ ] InterviewBit
  - [ ] LeetCode mock interviews
- [ ] **Practice Areas**
  - [ ] Problem-solving approach
  - [ ] Code optimization
  - [ ] Communication skills
  - [ ] Time management

### Company-Specific Preparation

- [ ] **Google**
  - [ ] Focus on algorithms and data structures
  - [ ] System design for senior roles
- [ ] **Amazon**
  - [ ] Leadership principles
  - [ ] Scalability problems
- [ ] **Facebook/Meta**
  - [ ] Product sense
  - [ ] Coding and system design
- [ ] **Apple**
  - [ ] Design-focused problems
  - [ ] Performance optimization
- [ ] **Netflix**
  - [ ] Scalability and performance
  - [ ] Distributed systems

## 10. Final Preparation Checklist

### Technical Preparation

- [ ] **Problem-Solving Speed**
  - [ ] Solve medium problems in 20-30 minutes
  - [ ] Solve hard problems in 45-60 minutes
- [ ] **Code Quality**
  - [ ] Clean, readable code
  - [ ] Proper variable naming
  - [ ] Edge case handling
- [ ] **Optimization Skills**
  - [ ] Time complexity optimization
  - [ ] Space complexity optimization
  - [ ] Algorithm selection

### Soft Skills

- [ ] **Communication**
  - [ ] Explain thought process clearly
  - [ ] Ask clarifying questions
  - [ ] Handle hints gracefully
- [ ] **Problem-Solving Approach**
  - [ ] Understand the problem completely
  - [ ] Discuss approach before coding
  - [ ] Test with examples
  - [ ] Debug systematically

### Interview Day Preparation

- [ ] **Environment Setup**
  - [ ] Stable internet connection
  - [ ] Quiet environment
  - [ ] Backup communication methods
- [ ] **Mental Preparation**
  - [ ] Good night's sleep
  - [ ] Healthy breakfast
  - [ ] Relaxation techniques
- [ ] **Last-Minute Review**
  - [ ] Common algorithms
  - [ ] Time complexity cheat sheet
  - [ ] Company-specific notes

## Resources and References

### Books

- [ ] "Cracking the Coding Interview" by Gayle McDowell
- [ ] "Introduction to Algorithms" by Cormen, Leiserson, Rivest, and Stein
- [ ] "Algorithm Design" by Jon Kleinberg and Ã‰va Tardos
- [ ] "Elements of Programming Interviews" by Aziz, Lee, and Prakash

### Online Courses

- [ ] Coursera: Algorithms Specialization (Stanford)
- [ ] edX: Introduction to Algorithms (MIT)
- [ ] Udemy: Master the Coding Interview courses
- [ ] YouTube: MIT 6.006 Introduction to Algorithms

### Additional Practice

- [ ] Daily coding challenges
- [ ] Weekend contest participation
- [ ] Peer programming sessions
- [ ] Open source contributions

---

**Estimated Timeline:** 6-12 months of consistent practice (2-3 hours daily)

**Priority Order:**

1. Basic data structures and algorithms (2-3 months)
2. Advanced algorithms and problem-solving patterns (2-3 months)
3. System design basics (1-2 months)
4. Intensive practice and mock interviews (2-3 months)

Good luck with your FAANG interview preparation! Remember to practice consistently, focus on understanding concepts deeply, and maintain a growth mindset throughout your journey.
